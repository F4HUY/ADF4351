/* ADF4351 Generator - original code from OE6OCG modified by F4HUY rev2
 * www.f4huy.fr - f4huy.ham@gmail.com
 * 35Mhz to 4.4GHz
 * Ref 10Mz
 * Using a LCD 2x20 with I2C <LiquidCrystal_I2C> if you don't know the i2c adress board, use http://playground.arduino.cc/Main/I2cScanner
 * Using rotativ encoder on pin 2/3 (interrupt)
 * Step button connected to pin 4 with 10k pullup
 * int LoNoisSpur = 1; //Low Spurious Mode
 * int D_out_PWR = 11; //POut +5db
 * int D_RF_ena = 1; // 1 = rf out ON - 0 rf out OFF

DONT FORGET TO INSERT A LEVEL SHIFTER BETWEN ARDUINO AND ADF4351 BOARD

Mega2560 SPI
50 MISO (Master In Slave Out)
51 MOSI (Master Out Slave In)
53 SS
52 SCK (Serial Clock)

UNO SPI
12 MISO (Master In Slave Out) - The Slave line for sending data to the master,
11 MOSI (Master Out Slave In) - The Master line for sending data to the peripherals,
13 SCK (Serial Clock) - The clock pulses which synchronize data transmission generated by the master 
*/

#include <LiquidCrystal_I2C.h>
#include <SoftwareSerial.h>
#include <Wire.h>
#include <SPI.h>
LiquidCrystal_I2C lcd(0x3F, 20, 2);

const int slaveSelectPin = 10;  //SPI Select pin 10
long Freq;
long refin = 1000000; // Ref 10mhz
long freq_step;
unsigned long Reg[6]; //ADF4351 Reg's

byte tenHz, hundredHz, ones, tens, hundreds, thousands, tenthousands, hundredthousands, millions; 

//Rotativ encoder
volatile byte enc = 0;
#define PINA 2
#define PINB 3
#define INTERRUPT 0 

const int stepPin = 4;     // Step button pin 4
int stepPushCounter = 0;
int stepState = 0;    
int laststepState = 0;

const int bandPin = 5;     // Band button pin 5
int bandPushCounter = 0;
int bandState = 0;      
int lastbandState = 0;

void setup ()
{    
  Serial.begin(57600);
    
  //LCD
  lcd.begin();
  lcd.backlight();
  lcd.setCursor(0, 0);
  lcd.print("ADF4351 Rf Generator");
  delay(1500);  
  lcd.clear();
  //Pin assignation
  pinMode(2, INPUT); //encodeur
  pinMode(3, INPUT); //encodeur

  //SPI
  pinMode (slaveSelectPin, OUTPUT);
  digitalWrite(slaveSelectPin, LOW);
  SPI.setDataMode(SPI_MODE0);
  SPI.setBitOrder(MSBFIRST);
  SPI.setClockDivider(SPI_CLOCK_DIV128);
  SPI.begin();
  delay(500);
  band(); //frequncy bands selector
  SetFreq(Freq);  //update freq at power up
  delay(250);  
  
  //Rotativ encoder
  digitalWrite (PINA, HIGH);     
  digitalWrite (PINB, HIGH); 
  attachInterrupt(0,Read_Encoder_1,FALLING);
  int i = 1;
}

void loop()
{
  //call under loop
  encoder();
  step_size();

  bandState = digitalRead(bandPin);
   if (bandState != lastbandState)
   {
   if (bandState == LOW)
   bandPushCounter++;
   delay(250);
   band();
   lastbandState = bandState;
   }
}

void Read_Encoder_1()
{
  for (byte i=0; i<3; i++)
  {
    if (digitalRead(PINA) == digitalRead(PINB))
    {
      enc = 1;
    }
    else
    {
      enc = 2;
    }
  }
}

////////////////////////////////////////////////////////////////LCD DISPLAY////////////////////////////////////////////////////////////////
void showFreq(long FREQ) {
  millions = int(FREQ / 100000000);
  hundredthousands = ((FREQ / 10000000) % 10);
  tenthousands = ((FREQ / 1000000) % 10);
  thousands = ((FREQ / 100000) % 10);
  hundreds = ((FREQ / 10000) % 10);
  tens = ((FREQ / 1000) % 10);
  ones = ((FREQ / 100) % 10);
  hundredHz = ((FREQ / 10) % 10);
  tenHz = ((FREQ) % 10);
  lcd.setCursor(0, 0);
  lcd.print("            ");
  if (millions > 0) {
    lcd.setCursor(0, 0);
    lcd.print(millions);
    lcd.print(".");
  }
  else {
    lcd.setCursor(0, 0);
  }
  lcd.print(hundredthousands);
  lcd.print(tenthousands);
  lcd.print(thousands);
  lcd.print(",");
  lcd.print(hundreds);
  lcd.print(tens);
  lcd.print(ones);
  lcd.print(".");
  lcd.print(hundredHz);
  lcd.print(tenHz);

  lcd.setCursor(11, 0);
  lcd.print(" Mhz");// print Mhz
};

////////////////////////////////////////////////////////////////SEND DATA////////////////////////////////////////////////////////////////
void SetFreq(long Freq)
{
  showFreq(Freq);
  ConvertFreq(Freq, Reg);
  WriteADF2(5);
  delayMicroseconds(2500);
  WriteADF2(4);
  delayMicroseconds(2500);
  WriteADF2(3);
  delayMicroseconds(2500);
  WriteADF2(2);
  delayMicroseconds(2500);
  WriteADF2(1);
  delayMicroseconds(2500);
  WriteADF2(0);
  delayMicroseconds(2500);
}

void WriteADF2(int idx)
{ // make 4 byte from integer for SPI-Transfer
  byte buf[4];
  for (int i = 0; i < 4; i++)
    buf[i] = (byte)(Reg[idx] >> (i * 8));
  WriteADF(buf[3], buf[2], buf[1], buf[0]);
}

int WriteADF(byte a1, byte a2, byte a3, byte a4) {
  // write over SPI to ADF4350
  digitalWrite(slaveSelectPin, LOW);
  delayMicroseconds(10);
  SPI.transfer(a1);
  SPI.transfer(a2);
  SPI.transfer(a3);
  SPI.transfer(a4);
  Toggle();
}

int Toggle() {
  digitalWrite(slaveSelectPin, HIGH);
  delayMicroseconds(5);
  digitalWrite(slaveSelectPin, LOW);
}

void ConvertFreq(long freq, unsigned long R[])
{
  // PLL-Reg-R0         =  32bit
  // Registerselect        3bit
  // int F_Frac = 4;       // 12bit
  // int N_Int = 92;       // 16bit
  // reserved           // 1bit

  // PLL-Reg-R1         =  32bit
  // Registerselect        3bit
  int P_Phase = 1;     // 12bit - 2x12bit
  int Prescal = 0;     // 1bit
  int PhaseAdj = 0;    // 1bit
  // reserved           // 3bit

  // PLL-Reg-R2         =  32bit
  // Registerselect        3bit
  int U1_CountRes = 0; // 1bit
  int U2_Cp3state = 0; // 1bit
  int U3_PwrDown = 0;  // 1bit
  int U4_PDpola = 1;    // 1bit
  int U5_LPD = 0;       // 1bit
  int U6_LPF = 1;       // 1bit 1=Integer, 0=Frac not spported yet
  int CP_ChgPump = 7;     // 4bit
  int D1_DoublBuf = 0; // 1bit
  int M_Muxout = 0;     // 3bit
  int LoNoisSpur = 1;   // 2bit
  // reserved           // 1bit

  // PLL-Reg-R3         =  32bit
  // Registerselect        3bit
  int D_Clk_div = 150; // 12bit
  int C_Clk_mode = 0;   // 2bit
  //  reserved          // 1bit
  int F1_Csr = 0;       // 1bit
  //  reserved          // 2bit
  int F2_ChgChan = 0;   // 1bit
  int F3_ADB = 1;       // 1bit
  int F4_BandSel = 0;  // 1bit
  //  reserved          // 8bit

  // PLL-Reg-R4         =  32bit
  // Registerselect        3bit
  int D_out_PWR = 11;    // 2bit
  int D_RF_ena = 1;     // 1bit
  int D_auxOutPwr = 11;  // 2bit
  int D_auxOutEna = 0;  // 1bit
  int D_auxOutSel = 0;  // 1bit
  int D_MTLD = 0;       // 1bit
  int D_VcoPwrDown = 0; // 1bit 1=VCO off

  //  int B_BandSelClk = 200; // 8bit

  int D_RfDivSel = 3;    // 3bit 3=70cm 4=2m
  int D_FeedBck = 1;     // 1bit
  // reserved           // 8bit

  // PLL-Reg-R5         =  32bit
  // Registerselect     // 3bit
  // reserved           // 16bit
  // reserved     11    // 2bit
  // reserved           // 1bit
  int D_LdPinMod = 1;    // 2bit muss 1 sein
  // reserved           // 8bit

  // Ref Freg Calc
  int R_Counter = 1;   // 10bit
  int RD1_Rdiv2 = 0;    // 1bit
  int RD2refdoubl = 0; // 1bit
  int B_BandSelClk = 200; // 8bit

  long RFout = Freq;   // VCO-Freq

  // calc bandselect und RF-div
  int outdiv = 1;

  if (RFout >= 220000000) {
    outdiv = 1;
    D_RfDivSel = 0;
  }
  if (RFout < 220000000) {
    outdiv = 2;
    D_RfDivSel = 1;
  }
  if (RFout < 110000000) {
    outdiv = 4;
    D_RfDivSel = 2;
  }
  if (RFout < 55000000) {
    outdiv = 8;
    D_RfDivSel = 3;
  }
  if (RFout < 27500000) {
    outdiv = 16;
    D_RfDivSel = 4;
  }
  if (RFout < 13800000) {
    outdiv = 32;
    D_RfDivSel = 5;
  }
  if (RFout < 6900000) {
    outdiv = 64;
    D_RfDivSel = 6;
  }

  float PFDFreq = refin * ((1.0 + RD2refdoubl) / (R_Counter * (1.0 + RD1_Rdiv2)));
  float N = ((RFout) * outdiv) / PFDFreq;
  int N_Int = N;
  long M_Mod = PFDFreq * (100000 / freq_step) / 100000;
  int F_Frac = round((N - N_Int) * M_Mod);

  R[0] = (unsigned long)(0 + F_Frac * pow(2, 3) + N_Int * pow(2, 15));
  R[1] = (unsigned long)(1 + M_Mod * pow(2, 3) + P_Phase * pow(2, 15) + Prescal * pow(2, 27) + PhaseAdj * pow(2, 28));
  R[2] = (unsigned long)(2 + U1_CountRes * pow(2, 3) + U2_Cp3state * pow(2, 4) + U3_PwrDown * pow(2, 5) + U4_PDpola * pow(2, 6) + U5_LPD * pow(2, 7) + U6_LPF * pow(2, 8) + CP_ChgPump * pow(2, 9) + D1_DoublBuf * pow(2, 13) + R_Counter * pow(2, 14) + RD1_Rdiv2 * pow(2, 24) + RD2refdoubl * pow(2, 25) + M_Muxout * pow(2, 26) + LoNoisSpur * pow(2, 29));
  R[3] = (unsigned long)(3 + D_Clk_div * pow(2, 3) + C_Clk_mode * pow(2, 15) + 0 * pow(2, 17) + F1_Csr * pow(2, 18) + 0 * pow(2, 19) + F2_ChgChan * pow(2, 21) +  F3_ADB * pow(2, 22) + F4_BandSel * pow(2, 23) + 0 * pow(2, 24));
  R[4] = (unsigned long)(4 + D_out_PWR * pow(2, 3) + D_RF_ena * pow(2, 5) + D_auxOutPwr * pow(2, 6) + D_auxOutEna * pow(2, 8) + D_auxOutSel * pow(2, 9) + D_MTLD * pow(2, 10) + D_VcoPwrDown * pow(2, 11) + B_BandSelClk * pow(2, 12) + D_RfDivSel * pow(2, 20) + D_FeedBck * pow(2, 23));
  R[5] = (unsigned long)(5 + 0 * pow(2, 3) + 3 * pow(2, 19) + 0 * pow(2, 21) + D_LdPinMod * pow(2, 22));
}

////////////////////////////////////////////////////////////////SEND DATA////////////////////////////////////////////////////////////////

